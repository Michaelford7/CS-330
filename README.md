# CS-330
1. How do I approach designing software?

When I design software, I usually start by trying to understand the bigger picture before jumping into the code. For this project, I first looked at my real workstation and thought about how I could break it down into simple shapes like boxes, cylinders, planes, and a torus. Instead of trying to make everything perfect right away, I focused on building the main structure first and then slowly adding details like textures and lighting. That helped me stay organized and not feel overwhelmed by everything happening in a 3D environment.

What new design skills did I develop?

One of the biggest things I improved on was thinking in 3D space. Positioning objects correctly using X, Y, and Z coordinates took practice, especially when matching the layout to my reference image. I also learned how much lighting affects realism. Adjusting ambient, diffuse, and specular values changed the entire feel of the scene. Before this project, I didn’t fully understand how material properties like shininess could make something look metallic versus matte. That was a big learning moment for me.

What design process did I follow?

I worked through the project in layers. First I created the basic objects. Then I refined their placement. After that I added textures. Finally, I worked on lighting and camera adjustments. I made small changes and tested constantly. A lot of the progress came from trial and error. If something looked off, I would tweak values slightly and see what happened. That iterative approach helped me gradually improve the scene without breaking everything at once.

How could I apply this approach in the future?

Breaking problems into smaller pieces and building step by step is something I can use in any programming project. This project reminded me that clean structure matters just as much as functionality. Using reusable functions like transformation and texture setup kept my code manageable, and that is something I plan to continue doing in future classes and professional work.

____________________________________________________________________________________________________________________________________________________________________________________________________________________________

2. How do I approach developing programs?

When developing code, I try to keep things readable and modular. I don’t like repeating the same logic over and over if I can avoid it. In this project, functions like SetTransformations helped me avoid rewriting scaling, rotation, and translation logic for every object. That made debugging easier and helped me stay organized.

What new strategies did I use?

One new strategy I used was really paying attention to visual debugging. If something looked too bright or unrealistic, I learned to adjust specific shader values instead of guessing. I also became more comfortable changing small pieces of code and testing immediately rather than rewriting large sections at once.

How did iteration factor into development?

Iteration was honestly the biggest part of this project. I moved objects multiple times, adjusted lighting values repeatedly, and refined camera movement until everything felt right. Each milestone built on the last one, so I was constantly improving rather than starting over. I think that helped the final project feel more complete.

How has my approach evolved?

At the beginning of the course, I was mostly focused on getting things to work. By the end, I cared more about structure, clarity, and presentation. I started thinking ahead about how changes would affect other parts of the program.

____________________________________________________________________________________________________________________________________________________________________________________________________________________________

3. How can computer science help me reach my goals?

Computer science gives me structured problem-solving skills that apply to everything I want to do professionally. This project especially improved my confidence working with C++ and more complex systems. It showed me that I can take a concept and build something functional and visual from scratch.

How does computational graphics apply to my education?

Working with transformations and coordinate systems made abstract math concepts feel practical. Instead of just reading about them, I could actually see the results on screen. That hands-on experience helps my critical thinking for future projects.

How does this apply professionally?

Even if I do not work directly in graphics, the skills from this course transfer to software engineering in general. Writing modular code, debugging step by step, and thinking about user interaction are all relevant in professional development environments. This project also helped me appreciate how visual feedback can improve software usability.
